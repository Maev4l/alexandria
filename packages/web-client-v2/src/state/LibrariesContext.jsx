// Generated by Claude.
// Libraries state management via React Context
// Provides shared state for libraries across the application
import { createContext, useContext, useState, useCallback, useMemo } from 'react';
import { librariesApi } from '@/api';

const LibrariesContext = createContext(null);

export const LibrariesProvider = ({ children }) => {
  const [libraries, setLibraries] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Fetch all libraries
  const fetchLibraries = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await librariesApi.getAll();
      setLibraries(data.libraries || []);
    } catch (err) {
      setError(err.message);
      setLibraries([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Create a new library
  const createLibrary = useCallback(async (data) => {
    const result = await librariesApi.create(data);
    // Refetch to get the complete library data
    await fetchLibraries();
    return result;
  }, [fetchLibraries]);

  // Update a library
  const updateLibrary = useCallback(async (libraryId, data) => {
    await librariesApi.update(libraryId, data);
    // Update local state
    setLibraries((prev) =>
      prev.map((lib) =>
        lib.id === libraryId ? { ...lib, ...data } : lib
      )
    );
  }, []);

  // Delete a library
  const deleteLibrary = useCallback(async (libraryId) => {
    await librariesApi.delete(libraryId);
    // Remove from local state
    setLibraries((prev) => prev.filter((lib) => lib.id !== libraryId));
  }, []);

  // Share a library with another user
  const shareLibrary = useCallback(async (libraryId, userName) => {
    await librariesApi.share(libraryId, userName);
    // Update local state to reflect the new share
    setLibraries((prev) =>
      prev.map((lib) =>
        lib.id === libraryId
          ? { ...lib, sharedTo: [...(lib.sharedTo || []), userName] }
          : lib
      )
    );
  }, []);

  // Separate owned vs shared libraries, sorted alphabetically by name
  const ownedLibraries = useMemo(
    () => libraries
      .filter((lib) => !lib.sharedFrom)
      .sort((a, b) => a.name.localeCompare(b.name)),
    [libraries]
  );

  const sharedLibraries = useMemo(
    () => libraries
      .filter((lib) => lib.sharedFrom)
      .sort((a, b) => a.name.localeCompare(b.name)),
    [libraries]
  );

  const value = useMemo(() => ({
    libraries,
    ownedLibraries,
    sharedLibraries,
    isLoading,
    error,
    fetchLibraries,
    createLibrary,
    updateLibrary,
    deleteLibrary,
    shareLibrary,
  }), [
    libraries,
    ownedLibraries,
    sharedLibraries,
    isLoading,
    error,
    fetchLibraries,
    createLibrary,
    updateLibrary,
    deleteLibrary,
    shareLibrary,
  ]);

  return (
    <LibrariesContext.Provider value={value}>
      {children}
    </LibrariesContext.Provider>
  );
};

export const useLibraries = () => {
  const context = useContext(LibrariesContext);
  if (!context) {
    throw new Error('useLibraries must be used within a LibrariesProvider');
  }
  return context;
};
