// Generated by Claude.
// Extracts dominant color from an image for dynamic theming
// Used to create ambient backgrounds on detail pages

/**
 * Extracts the dominant color from an image URL
 * Uses canvas sampling for performance (small sample size)
 * @param {string} imageUrl - URL or base64 data URI of the image
 * @returns {Promise<{r: number, g: number, b: number}>} RGB color object
 */
export const extractDominantColor = (imageUrl) => {
  return new Promise((resolve) => {
    // Default fallback color (muted purple to match theme)
    const fallback = { r: 80, g: 70, b: 120 };

    if (!imageUrl) {
      resolve(fallback);
      return;
    }

    const img = new Image();
    img.crossOrigin = 'anonymous';

    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Sample at small size for performance
        const sampleSize = 10;
        canvas.width = sampleSize;
        canvas.height = sampleSize;

        ctx.drawImage(img, 0, 0, sampleSize, sampleSize);
        const data = ctx.getImageData(0, 0, sampleSize, sampleSize).data;

        // Calculate weighted average (center pixels weighted more)
        let r = 0, g = 0, b = 0, totalWeight = 0;
        const centerX = sampleSize / 2;
        const centerY = sampleSize / 2;

        for (let y = 0; y < sampleSize; y++) {
          for (let x = 0; x < sampleSize; x++) {
            const i = (y * sampleSize + x) * 4;

            // Skip very dark or very light pixels (likely background/text)
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            if (brightness < 20 || brightness > 235) continue;

            // Weight by distance from center (center pixels matter more)
            const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            const weight = 1 / (1 + dist * 0.3);

            r += data[i] * weight;
            g += data[i + 1] * weight;
            b += data[i + 2] * weight;
            totalWeight += weight;
          }
        }

        if (totalWeight > 0) {
          resolve({
            r: Math.round(r / totalWeight),
            g: Math.round(g / totalWeight),
            b: Math.round(b / totalWeight),
          });
        } else {
          resolve(fallback);
        }
      } catch {
        // Canvas security error or other issue
        resolve(fallback);
      }
    };

    img.onerror = () => resolve(fallback);

    // Handle base64 data URIs
    if (imageUrl.startsWith('data:')) {
      img.src = imageUrl;
    } else {
      img.src = imageUrl;
    }
  });
};

/**
 * Creates a CSS gradient string from an extracted color
 * Gradient fades from color at top to transparent
 * @param {{r: number, g: number, b: number}} color - RGB color object
 * @param {number} opacity - Opacity of the color (0-1)
 * @returns {string} CSS gradient string
 */
export const createCoverGradient = (color, opacity = 0.4) => {
  return `radial-gradient(ellipse 120% 80% at 50% 0%, rgba(${color.r}, ${color.g}, ${color.b}, ${opacity}) 0%, transparent 70%)`;
};

/**
 * Determines if a color is "light" (for choosing contrasting text)
 * @param {{r: number, g: number, b: number}} color - RGB color object
 * @returns {boolean} True if the color is light
 */
export const isLightColor = (color) => {
  // Using relative luminance formula
  const luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255;
  return luminance > 0.5;
};

/**
 * React hook for extracting color from an image
 * Returns the color and a loading state
 */
import { useState, useEffect } from 'react';

export const useExtractedColor = (imageUrl) => {
  const [color, setColor] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (!imageUrl) {
      setColor(null);
      return;
    }

    setIsLoading(true);
    extractDominantColor(imageUrl)
      .then((extracted) => {
        setColor(extracted);
        setIsLoading(false);
      })
      .catch(() => {
        setColor(null);
        setIsLoading(false);
      });
  }, [imageUrl]);

  return { color, isLoading };
};
