// Generated by Claude.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/tabwriter"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
	"github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider/types"
)

const (
	approvedAttr = "custom:Approved"
	envPoolID    = "COGNITO_USER_POOL_ID"
)

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	// Parse command (skip --pool-id if present)
	args := filterPoolIDFlag(os.Args[1:])
	if len(args) == 0 {
		printUsage()
		os.Exit(1)
	}

	cmd := args[0]
	cmdArgs := args[1:]

	// Help doesn't require pool ID
	if cmd == "help" || cmd == "-h" || cmd == "--help" {
		printUsage()
		return
	}

	poolID := getPoolID()
	if poolID == "" {
		fmt.Fprintf(os.Stderr, "Error: User Pool ID required. Use --pool-id, set %s, or provide config.json\n", envPoolID)
		os.Exit(1)
	}

	ctx := context.Background()
	client, err := newCognitoClient(ctx)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating AWS client: %v\n", err)
		os.Exit(1)
	}

	switch cmd {
	case "list":
		if err := listUsers(ctx, client, poolID); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}
	case "approve":
		if len(cmdArgs) < 1 {
			fmt.Fprintln(os.Stderr, "Error: username required")
			fmt.Fprintln(os.Stderr, "Usage: alexandria approve <username>")
			os.Exit(1)
		}
		if err := setApproval(ctx, client, poolID, cmdArgs[0], true); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}
	case "unapprove":
		if len(cmdArgs) < 1 {
			fmt.Fprintln(os.Stderr, "Error: username required")
			fmt.Fprintln(os.Stderr, "Usage: alexandria unapprove <username>")
			os.Exit(1)
		}
		if err := setApproval(ctx, client, poolID, cmdArgs[0], false); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}
	default:
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n", cmd)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println(`alexandria - Cognito user management CLI

Usage:
  alexandria <command> [arguments]

Commands:
  list                   List all users
  approve <username>     Approve a user (set custom:Approved = true)
  unapprove <username>   Unapprove a user (set custom:Approved = false)
  help                   Show this help

Configuration (priority order):
  --pool-id <id>       Cognito User Pool ID
  COGNITO_USER_POOL_ID Environment variable
  config.json          File next to binary (alexandriaUserPoolId field)`)
}

// getPoolID retrieves pool ID from flag, environment, or config file
// Priority: --pool-id flag > COGNITO_USER_POOL_ID env > config.json
func getPoolID() string {
	// Check for --pool-id flag
	for i, arg := range os.Args {
		if arg == "--pool-id" && i+1 < len(os.Args) {
			return os.Args[i+1]
		}
		if strings.HasPrefix(arg, "--pool-id=") {
			return strings.TrimPrefix(arg, "--pool-id=")
		}
	}

	// Check environment variable
	if envValue := os.Getenv(envPoolID); envValue != "" {
		return envValue
	}

	// Fallback: read from config.json next to binary
	return getPoolIDFromConfig()
}

// getPoolIDFromConfig reads the pool ID from config.json in the binary's directory
func getPoolIDFromConfig() string {
	execPath, err := os.Executable()
	if err != nil {
		return ""
	}

	configPath := filepath.Join(filepath.Dir(execPath), "config.json")
	data, err := os.ReadFile(configPath)
	if err != nil {
		return ""
	}

	var cfg struct {
		AlexandriaUserPoolId string `json:"alexandriaUserPoolId"`
	}
	if err := json.Unmarshal(data, &cfg); err != nil {
		return ""
	}

	return cfg.AlexandriaUserPoolId
}

// filterPoolIDFlag removes --pool-id and its value from args
func filterPoolIDFlag(args []string) []string {
	var filtered []string
	skip := false
	for _, arg := range args {
		if skip {
			skip = false
			continue
		}
		if arg == "--pool-id" {
			skip = true
			continue
		}
		if strings.HasPrefix(arg, "--pool-id=") {
			continue
		}
		filtered = append(filtered, arg)
	}
	return filtered
}

func newCognitoClient(ctx context.Context) (*cognitoidentityprovider.Client, error) {
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return nil, fmt.Errorf("loading AWS config: %w", err)
	}
	return cognitoidentityprovider.NewFromConfig(cfg), nil
}

func listUsers(ctx context.Context, client *cognitoidentityprovider.Client, poolID string) error {
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
	fmt.Fprintln(w, "USERNAME\tEMAIL\tPROVIDER\tSTATUS\tAPPROVED\tCREATED")

	var paginationToken *string
	for {
		resp, err := client.ListUsers(ctx, &cognitoidentityprovider.ListUsersInput{
			UserPoolId:      aws.String(poolID),
			PaginationToken: paginationToken,
		})
		if err != nil {
			return fmt.Errorf("listing users: %w", err)
		}

		for _, user := range resp.Users {
			// Username is what Cognito API expects (email for native, Provider_id for federated)
			username := aws.ToString(user.Username)
			email := getAttributeValue(user.Attributes, "email")
			provider := getProvider(user.Attributes)
			status := string(user.UserStatus)
			approved := getAttributeValue(user.Attributes, approvedAttr)
			created := ""
			if user.UserCreateDate != nil {
				created = user.UserCreateDate.Format("2006-01-02 15:04")
			}
			fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\n", username, email, provider, status, approved, created)
		}

		paginationToken = resp.PaginationToken
		if paginationToken == nil {
			break
		}
	}

	return w.Flush()
}

// getProvider extracts the identity provider from the identities attribute
// Returns "Native" for native users, or the provider name (e.g., "Google") for federated
func getProvider(attrs []types.AttributeType) string {
	identities := getAttributeValue(attrs, "identities")
	if identities == "-" || identities == "" || identities == "[]" {
		return "Native"
	}

	// identities is a JSON array like: [{"providerName":"Google","providerType":"Google",...}]
	var parsed []struct {
		ProviderName string `json:"providerName"`
	}
	if err := json.Unmarshal([]byte(identities), &parsed); err != nil {
		return "Native"
	}

	if len(parsed) > 0 && parsed[0].ProviderName != "" {
		return parsed[0].ProviderName
	}
	return "Native"
}

func setApproval(ctx context.Context, client *cognitoidentityprovider.Client, poolID, username string, approved bool) error {
	value := "false"
	if approved {
		value = "true"
	}

	_, err := client.AdminUpdateUserAttributes(ctx, &cognitoidentityprovider.AdminUpdateUserAttributesInput{
		UserPoolId: aws.String(poolID),
		Username:   aws.String(username),
		UserAttributes: []types.AttributeType{
			{
				Name:  aws.String(approvedAttr),
				Value: aws.String(value),
			},
		},
	})
	if err != nil {
		return fmt.Errorf("updating user %s: %w", username, err)
	}

	action := "approved"
	if !approved {
		action = "unapproved"
	}
	fmt.Printf("User %s has been %s\n", username, action)
	return nil
}

func getAttributeValue(attrs []types.AttributeType, name string) string {
	for _, attr := range attrs {
		if aws.ToString(attr.Name) == name {
			return aws.ToString(attr.Value)
		}
	}
	return "-"
}
