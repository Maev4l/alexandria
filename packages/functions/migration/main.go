// Generated by Claude.
// Migration tool to recompute DynamoDB GSI sort keys with normalized values.
// This fixes alphabetical sorting issues caused by UTF-8 byte order with accented characters.
//
// Usage:
//   go run main.go --table alexandria [--dry-run] [--verbose]
//
// The tool will:
// 1. Scan all LIBRARY, COLLECTION, BOOK, and VIDEO entities
// 2. Recompute GSI1SK (and GSI2SK for items) using normalized sort values
// 3. Update items in batch (25 per request)
//
// Use --dry-run to preview changes without writing to DynamoDB.
package main

import (
	"context"
	"flag"
	"fmt"
	"os"

	"alexandria.isnan.eu/functions/internal/persistence"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

var (
	tableName string
	dryRun    bool
	verbose   bool
)

func main() {
	flag.StringVar(&tableName, "table", "", "DynamoDB table name (required)")
	flag.BoolVar(&dryRun, "dry-run", false, "Preview changes without writing to DynamoDB")
	flag.BoolVar(&verbose, "verbose", false, "Show detailed output for each item")
	flag.Parse()

	if tableName == "" {
		fmt.Fprintln(os.Stderr, "Error: --table is required")
		flag.Usage()
		os.Exit(1)
	}

	ctx := context.Background()
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading AWS config: %v\n", err)
		os.Exit(1)
	}

	client := dynamodb.NewFromConfig(cfg)

	if dryRun {
		fmt.Println("=== DRY RUN MODE - No changes will be written ===")
	}
	fmt.Printf("Migrating table: %s\n\n", tableName)

	// Track statistics
	stats := struct {
		libraries   int
		collections int
		items       int
		updated     int
		skipped     int
		errors      int
	}{}

	// Scan all items in the table
	paginator := dynamodb.NewScanPaginator(client, &dynamodb.ScanInput{
		TableName: aws.String(tableName),
	})

	var updates []types.WriteRequest

	for paginator.HasMorePages() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error scanning table: %v\n", err)
			os.Exit(1)
		}

		for _, item := range page.Items {
			entityType := getStringAttr(item, "EntityType")
			pk := getStringAttr(item, "PK")
			sk := getStringAttr(item, "SK")
			currentGSI1SK := getStringAttr(item, "GSI1SK")

			var newGSI1SK string
			var newGSI2SK string
			var description string

			switch entityType {
			case "LIBRARY":
				stats.libraries++
				name := getStringAttr(item, "LibraryName")
				newGSI1SK = persistence.MakeLibraryGSI1SK(name)
				description = fmt.Sprintf("LIBRARY: %s", name)

			case "COLLECTION":
				stats.collections++
				name := getStringAttr(item, "CollectionName")
				newGSI1SK = persistence.MakeCollectionGSI1SK(name)
				description = fmt.Sprintf("COLLECTION: %s", name)

			case "BOOK", "VIDEO":
				stats.items++
				title := getStringAttr(item, "Title")
				collectionName := getStringPtrAttr(item, "CollectionName")
				order := getIntPtrAttr(item, "Order")
				newGSI1SK = persistence.MakeLibraryItemGSI1SK(title, collectionName, order)
				newGSI2SK = persistence.MakeLibraryItemGSI2SK(title)
				description = fmt.Sprintf("%s: %s", entityType, title)

			default:
				// Skip other entity types (SHARED_LIBRARY, EVENT, etc.)
				continue
			}

			// Check if GSI1SK needs updating
			gsi1Changed := currentGSI1SK != newGSI1SK
			gsi2Changed := false
			if entityType == "BOOK" || entityType == "VIDEO" {
				currentGSI2SK := getStringAttr(item, "GSI2SK")
				gsi2Changed = currentGSI2SK != newGSI2SK
			}

			if !gsi1Changed && !gsi2Changed {
				stats.skipped++
				if verbose {
					fmt.Printf("  [SKIP] %s (already normalized)\n", description)
				}
				continue
			}

			stats.updated++

			if verbose {
				fmt.Printf("  [UPDATE] %s\n", description)
				if gsi1Changed {
					fmt.Printf("           GSI1SK: %s -> %s\n", currentGSI1SK, newGSI1SK)
				}
				if gsi2Changed {
					fmt.Printf("           GSI2SK: (changed)\n")
				}
			}

			if dryRun {
				continue
			}

			// Build update item - copy all attributes and update GSI keys
			updatedItem := make(map[string]types.AttributeValue)
			for k, v := range item {
				updatedItem[k] = v
			}
			updatedItem["GSI1SK"] = &types.AttributeValueMemberS{Value: newGSI1SK}
			if gsi2Changed {
				updatedItem["GSI2SK"] = &types.AttributeValueMemberS{Value: newGSI2SK}
			}

			updates = append(updates, types.WriteRequest{
				PutRequest: &types.PutRequest{
					Item: updatedItem,
				},
			})

			// Flush batch every 25 items
			if len(updates) >= 25 {
				if err := executeBatch(ctx, client, updates); err != nil {
					fmt.Fprintf(os.Stderr, "Error executing batch: %v\n", err)
					stats.errors++
				}
				updates = nil
			}

			_ = pk // silence unused warning
			_ = sk
		}
	}

	// Flush remaining updates
	if len(updates) > 0 && !dryRun {
		if err := executeBatch(ctx, client, updates); err != nil {
			fmt.Fprintf(os.Stderr, "Error executing final batch: %v\n", err)
			stats.errors++
		}
	}

	// Print summary
	fmt.Println()
	fmt.Println("=== Migration Summary ===")
	fmt.Printf("Libraries scanned:   %d\n", stats.libraries)
	fmt.Printf("Collections scanned: %d\n", stats.collections)
	fmt.Printf("Items scanned:       %d\n", stats.items)
	fmt.Printf("Records updated:     %d\n", stats.updated)
	fmt.Printf("Records skipped:     %d (already normalized)\n", stats.skipped)
	if stats.errors > 0 {
		fmt.Printf("Errors:              %d\n", stats.errors)
	}

	if dryRun {
		fmt.Println("\n=== DRY RUN - No changes were written ===")
	}
}

func executeBatch(ctx context.Context, client *dynamodb.Client, updates []types.WriteRequest) error {
	_, err := client.BatchWriteItem(ctx, &dynamodb.BatchWriteItemInput{
		RequestItems: map[string][]types.WriteRequest{
			tableName: updates,
		},
	})
	return err
}

func getStringAttr(item map[string]types.AttributeValue, key string) string {
	if v, ok := item[key]; ok {
		if sv, ok := v.(*types.AttributeValueMemberS); ok {
			return sv.Value
		}
	}
	return ""
}

func getStringPtrAttr(item map[string]types.AttributeValue, key string) *string {
	if v, ok := item[key]; ok {
		if sv, ok := v.(*types.AttributeValueMemberS); ok {
			return &sv.Value
		}
	}
	return nil
}

func getIntPtrAttr(item map[string]types.AttributeValue, key string) *int {
	if v, ok := item[key]; ok {
		var val int
		if err := attributevalue.Unmarshal(v, &val); err == nil {
			return &val
		}
	}
	return nil
}
