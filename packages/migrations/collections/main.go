// Generated by Claude.
// Migration CLI tool to convert Collection attribute to COLLECTION entities
// Run with --dry-run to preview changes without writing

package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/google/uuid"
)

// newId generates a normalized UUID (uppercase, no dashes)
// Matches the format used by identifier.NewId() in the main codebase
func newId() string {
	id := uuid.NewString()
	return strings.ToUpper(strings.ReplaceAll(id, "-", ""))
}

var tableName string

// LibraryItem represents the old item structure with Collection as a string
type LibraryItem struct {
	PK          string  `dynamodbav:"PK"`
	SK          string  `dynamodbav:"SK"`
	GSI1PK      string  `dynamodbav:"GSI1PK"`
	GSI1SK      string  `dynamodbav:"GSI1SK"`
	Id          string  `dynamodbav:"ItemId"`
	Title       string  `dynamodbav:"Title"`
	OwnerId     string  `dynamodbav:"OwnerId"`
	LibraryId   string  `dynamodbav:"LibraryId"`
	Collection  *string `dynamodbav:"Collection,omitempty"`
	Order       *int    `dynamodbav:"Order,omitempty"`
	EntityType  string  `dynamodbav:"EntityType"`
}

// CollectionGroup represents a unique collection to be created
type CollectionGroup struct {
	OwnerId   string
	LibraryId string
	Name      string
	Items     []LibraryItem
}

func main() {
	dryRun := flag.Bool("dry-run", false, "Preview changes without writing")
	table := flag.String("table", "", "DynamoDB table name (required)")
	region := flag.String("region", "eu-central-1", "AWS region")
	flag.Parse()

	if *table == "" {
		fmt.Println("Error: --table is required")
		flag.Usage()
		os.Exit(1)
	}
	tableName = *table

	ctx := context.Background()

	// Load AWS config
	cfg, err := config.LoadDefaultConfig(ctx, config.WithRegion(*region))
	if err != nil {
		log.Fatalf("Failed to load AWS config: %v", err)
	}

	client := dynamodb.NewFromConfig(cfg)

	fmt.Println("=== Collections Migration Tool ===")
	fmt.Printf("Table: %s\n", tableName)
	fmt.Printf("Region: %s\n", *region)
	fmt.Printf("Dry run: %v\n\n", *dryRun)

	// Step 1: Scan all items with Collection attribute
	fmt.Println("[1/4] Scanning items with Collection attribute...")
	items, err := scanItemsWithCollection(ctx, client)
	if err != nil {
		log.Fatalf("Failed to scan items: %v", err)
	}
	fmt.Printf("Found %d items with collections\n\n", len(items))

	if len(items) == 0 {
		fmt.Println("No items to migrate. Exiting.")
		return
	}

	// Step 2: Group items by (ownerId, libraryId, collectionName)
	fmt.Println("[2/4] Grouping items by collection...")
	groups := groupItemsByCollection(items)
	fmt.Printf("Found %d unique collections\n\n", len(groups))

	// Step 3: Display summary
	fmt.Println("[3/4] Migration plan:")
	for key, group := range groups {
		fmt.Printf("  - Collection '%s' in library %s: %d items\n",
			group.Name, group.LibraryId[:8]+"...", len(group.Items))
		_ = key
	}
	fmt.Println()

	if *dryRun {
		fmt.Println("[DRY RUN] No changes written. Remove --dry-run to execute migration.")
		return
	}

	// Step 4: Create collections and update items
	fmt.Println("[4/4] Executing migration...")
	successCount := 0
	errorCount := 0

	for _, group := range groups {
		collectionId := newId()
		now := time.Now().UTC()

		// Create COLLECTION entity
		err := createCollection(ctx, client, collectionId, group, &now)
		if err != nil {
			fmt.Printf("  ERROR creating collection '%s': %v\n", group.Name, err)
			errorCount++
			continue
		}

		// Update items with CollectionId and CollectionName
		for _, item := range group.Items {
			err := updateItemWithCollection(ctx, client, item, collectionId, group.Name)
			if err != nil {
				fmt.Printf("  ERROR updating item %s: %v\n", item.Id, err)
				errorCount++
				continue
			}
			successCount++
		}

		fmt.Printf("  Created collection '%s' (%s) with %d items\n",
			group.Name, collectionId[:8]+"...", len(group.Items))
	}

	fmt.Println()
	fmt.Println("=== Migration Complete ===")
	fmt.Printf("Collections created: %d\n", len(groups))
	fmt.Printf("Items updated: %d\n", successCount)
	fmt.Printf("Errors: %d\n", errorCount)
}

func scanItemsWithCollection(ctx context.Context, client *dynamodb.Client) ([]LibraryItem, error) {
	var items []LibraryItem

	// Scan for BOOK and VIDEO entities that have a Collection attribute
	scanInput := &dynamodb.ScanInput{
		TableName:        aws.String(tableName),
		FilterExpression: aws.String("attribute_exists(#col) AND #col <> :empty AND (#et = :book OR #et = :video)"),
		ExpressionAttributeNames: map[string]string{
			"#col": "Collection",
			"#et":  "EntityType",
		},
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":empty": &types.AttributeValueMemberS{Value: ""},
			":book":  &types.AttributeValueMemberS{Value: "BOOK"},
			":video": &types.AttributeValueMemberS{Value: "VIDEO"},
		},
	}

	paginator := dynamodb.NewScanPaginator(client, scanInput)
	for paginator.HasMorePages() {
		result, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, item := range result.Items {
			var libraryItem LibraryItem
			if err := attributevalue.UnmarshalMap(item, &libraryItem); err != nil {
				log.Printf("Warning: failed to unmarshal item: %v", err)
				continue
			}
			items = append(items, libraryItem)
		}
	}

	return items, nil
}

func groupItemsByCollection(items []LibraryItem) map[string]*CollectionGroup {
	groups := make(map[string]*CollectionGroup)

	for _, item := range items {
		if item.Collection == nil || *item.Collection == "" {
			continue
		}

		key := fmt.Sprintf("%s|%s|%s", item.OwnerId, item.LibraryId, *item.Collection)

		if group, exists := groups[key]; exists {
			group.Items = append(group.Items, item)
		} else {
			groups[key] = &CollectionGroup{
				OwnerId:   item.OwnerId,
				LibraryId: item.LibraryId,
				Name:      *item.Collection,
				Items:     []LibraryItem{item},
			}
		}
	}

	return groups
}

func createCollection(ctx context.Context, client *dynamodb.Client, collectionId string, group *CollectionGroup, now *time.Time) error {
	pk := fmt.Sprintf("owner#%s", group.OwnerId)
	sk := fmt.Sprintf("library#%s#collection#%s", group.LibraryId, collectionId)
	gsi1pk := fmt.Sprintf("owner#%s#library#%s", group.OwnerId, group.LibraryId)
	gsi1sk := fmt.Sprintf("collection#%s", group.Name)

	item := map[string]types.AttributeValue{
		"PK":             &types.AttributeValueMemberS{Value: pk},
		"SK":             &types.AttributeValueMemberS{Value: sk},
		"GSI1PK":         &types.AttributeValueMemberS{Value: gsi1pk},
		"GSI1SK":         &types.AttributeValueMemberS{Value: gsi1sk},
		"CollectionId":   &types.AttributeValueMemberS{Value: collectionId},
		"CollectionName": &types.AttributeValueMemberS{Value: group.Name},
		"Description":    &types.AttributeValueMemberS{Value: ""},
		"ItemCount":      &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", len(group.Items))},
		"OwnerId":        &types.AttributeValueMemberS{Value: group.OwnerId},
		"LibraryId":      &types.AttributeValueMemberS{Value: group.LibraryId},
		"EntityType":     &types.AttributeValueMemberS{Value: "COLLECTION"},
		"CreatedAt":      &types.AttributeValueMemberS{Value: now.Format(time.RFC3339Nano)},
		"UpdatedAt":      &types.AttributeValueMemberS{Value: now.Format(time.RFC3339Nano)},
	}

	_, err := client.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String(tableName),
		Item:      item,
	})

	return err
}

func updateItemWithCollection(ctx context.Context, client *dynamodb.Client, item LibraryItem, collectionId string, collectionName string) error {
	_, err := client.UpdateItem(ctx, &dynamodb.UpdateItemInput{
		TableName: aws.String(tableName),
		Key: map[string]types.AttributeValue{
			"PK": &types.AttributeValueMemberS{Value: item.PK},
			"SK": &types.AttributeValueMemberS{Value: item.SK},
		},
		UpdateExpression: aws.String("SET CollectionId = :colId, CollectionName = :colName"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":colId":   &types.AttributeValueMemberS{Value: collectionId},
			":colName": &types.AttributeValueMemberS{Value: collectionName},
		},
	})

	return err
}
